/**
 * The Meixner Project
 * The REST API of the Meixner education project
 *
 * OpenAPI spec version: 1.0
 * Contact: mate.szoke2@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {HttpClient, HttpEvent, HttpHeaders, HttpResponse} from '@angular/common/http';

import {Observable} from 'rxjs';

import {GroupingRequest} from '../model/groupingRequest';
import {GroupingResponse} from '../model/groupingResponse';
import {MemoryGameRequest} from '../model/memoryGameRequest';
import {MemoryGameResponse} from '../model/memoryGameResponse';
import {PairingRequest} from '../model/pairingRequest';
import {PairingResponse} from '../model/pairingResponse';
import {SentenceCompletionRequest} from '../model/sentenceCompletionRequest';
import {SentenceCompletionResponse} from '../model/sentenceCompletionResponse';
import {SentenceCreationRequest} from '../model/sentenceCreationRequest';
import {SentenceCreationResponse} from '../model/sentenceCreationResponse';
import {SortingRequest} from '../model/sortingRequest';
import {SortingResponse} from '../model/sortingResponse';
import {TrueFalseRequest} from '../model/trueFalseRequest';
import {TrueFalseResponse} from '../model/trueFalseResponse';

import {BASE_PATH} from '../variables';
import {Configuration} from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class EasyTasksService {

    protected basePath = 'http://meixner.herokuapp.com';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {

        if (configuration) {
            this.configuration = configuration;
            this.configuration.basePath = configuration.basePath || basePath || this.basePath;

        } else {
            this.configuration.basePath = basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Creates a new Grouping task.
     *
     * @param groupingRequest groupingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createGroupingUsingPOST(groupingRequest: GroupingRequest, observe?: 'body', reportProgress?: boolean): Observable<GroupingResponse>;
    public createGroupingUsingPOST(groupingRequest: GroupingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GroupingResponse>>;
    public createGroupingUsingPOST(groupingRequest: GroupingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GroupingResponse>>;
    public createGroupingUsingPOST(groupingRequest: GroupingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (groupingRequest === null || groupingRequest === undefined) {
            throw new Error('Required parameter groupingRequest was null or undefined when calling createGroupingUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<GroupingResponse>(`${this.configuration.basePath}/tasks/grouping`,
            groupingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Memory game task.
     *
     * @param memoryGameRequest request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMemoryGameUsingPOST(memoryGameRequest: MemoryGameRequest, observe?: 'body', reportProgress?: boolean): Observable<MemoryGameResponse>;
    public createMemoryGameUsingPOST(memoryGameRequest: MemoryGameRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MemoryGameResponse>>;
    public createMemoryGameUsingPOST(memoryGameRequest: MemoryGameRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MemoryGameResponse>>;
    public createMemoryGameUsingPOST(memoryGameRequest: MemoryGameRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (memoryGameRequest === null || memoryGameRequest === undefined) {
            throw new Error('Required parameter memoryGameRequest was null or undefined when calling createMemoryGameUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<MemoryGameResponse>(`${this.configuration.basePath}/tasks/memoryGame`,
            memoryGameRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Pairing task.
     *
     * @param pairingRequest pairingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createPairingUsingPOST(pairingRequest: PairingRequest, observe?: 'body', reportProgress?: boolean): Observable<PairingResponse>;
    public createPairingUsingPOST(pairingRequest: PairingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PairingResponse>>;
    public createPairingUsingPOST(pairingRequest: PairingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PairingResponse>>;
    public createPairingUsingPOST(pairingRequest: PairingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (pairingRequest === null || pairingRequest === undefined) {
            throw new Error('Required parameter pairingRequest was null or undefined when calling createPairingUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<PairingResponse>(`${this.configuration.basePath}/tasks/pairing`,
            pairingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Sentence Completion task.
     *
     * @param sentenceCompletionRequest sentenceCompletionRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSentenceCompletionUsingPOST(sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'body', reportProgress?: boolean): Observable<SentenceCompletionResponse>;
    public createSentenceCompletionUsingPOST(sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SentenceCompletionResponse>>;
    public createSentenceCompletionUsingPOST(sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SentenceCompletionResponse>>;
    public createSentenceCompletionUsingPOST(sentenceCompletionRequest: SentenceCompletionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (sentenceCompletionRequest === null || sentenceCompletionRequest === undefined) {
            throw new Error('Required parameter sentenceCompletionRequest was null or undefined when calling createSentenceCompletionUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<SentenceCompletionResponse>(`${this.configuration.basePath}/tasks/sentence_completion`,
            sentenceCompletionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Sentence creation task.
     *
     * @param sentenceCreationRequest sentenceCreationRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSentenceCreationUsingPOST(sentenceCreationRequest: SentenceCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<SentenceCreationResponse>;
    public createSentenceCreationUsingPOST(sentenceCreationRequest: SentenceCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SentenceCreationResponse>>;
    public createSentenceCreationUsingPOST(sentenceCreationRequest: SentenceCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SentenceCreationResponse>>;
    public createSentenceCreationUsingPOST(sentenceCreationRequest: SentenceCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (sentenceCreationRequest === null || sentenceCreationRequest === undefined) {
            throw new Error('Required parameter sentenceCreationRequest was null or undefined when calling createSentenceCreationUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<SentenceCreationResponse>(`${this.configuration.basePath}/tasks/sentence_creation`,
            sentenceCreationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new Sorting task.
     *
     * @param sortingRequest sortingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSortingUsingPOST(sortingRequest: SortingRequest, observe?: 'body', reportProgress?: boolean): Observable<SortingResponse>;
    public createSortingUsingPOST(sortingRequest: SortingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SortingResponse>>;
    public createSortingUsingPOST(sortingRequest: SortingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SortingResponse>>;
    public createSortingUsingPOST(sortingRequest: SortingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (sortingRequest === null || sortingRequest === undefined) {
            throw new Error('Required parameter sortingRequest was null or undefined when calling createSortingUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<SortingResponse>(`${this.configuration.basePath}/tasks/sorting`,
            sortingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new TrueFalse task.
     *
     * @param trueFalseRequest request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTrueFalseUsingPOST(trueFalseRequest: TrueFalseRequest, observe?: 'body', reportProgress?: boolean): Observable<TrueFalseResponse>;
    public createTrueFalseUsingPOST(trueFalseRequest: TrueFalseRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrueFalseResponse>>;
    public createTrueFalseUsingPOST(trueFalseRequest: TrueFalseRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrueFalseResponse>>;
    public createTrueFalseUsingPOST(trueFalseRequest: TrueFalseRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (trueFalseRequest === null || trueFalseRequest === undefined) {
            throw new Error('Required parameter trueFalseRequest was null or undefined when calling createTrueFalseUsingPOST.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TrueFalseResponse>(`${this.configuration.basePath}/tasks/trueFalse`,
            trueFalseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Grouping task by taskId.
     *
     * @param taskId taskId
     * @param groupingRequest groupingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateGroupingByIdUsingPATCH(taskId: number, groupingRequest: GroupingRequest, observe?: 'body', reportProgress?: boolean): Observable<GroupingResponse>;
    public updateGroupingByIdUsingPATCH(taskId: number, groupingRequest: GroupingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GroupingResponse>>;
    public updateGroupingByIdUsingPATCH(taskId: number, groupingRequest: GroupingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GroupingResponse>>;
    public updateGroupingByIdUsingPATCH(taskId: number, groupingRequest: GroupingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateGroupingByIdUsingPATCH.');
        }
        if (groupingRequest === null || groupingRequest === undefined) {
            throw new Error('Required parameter groupingRequest was null or undefined when calling updateGroupingByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<GroupingResponse>(`${this.configuration.basePath}/tasks/grouping/${encodeURIComponent(String(taskId))}`,
            groupingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Memory game task by taskId.
     *
     * @param taskId taskId
     * @param memoryGameRequest request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateMemoryGamedUsingPATCH(taskId: number, memoryGameRequest: MemoryGameRequest, observe?: 'body', reportProgress?: boolean): Observable<MemoryGameResponse>;
    public updateMemoryGamedUsingPATCH(taskId: number, memoryGameRequest: MemoryGameRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MemoryGameResponse>>;
    public updateMemoryGamedUsingPATCH(taskId: number, memoryGameRequest: MemoryGameRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MemoryGameResponse>>;
    public updateMemoryGamedUsingPATCH(taskId: number, memoryGameRequest: MemoryGameRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateMemoryGamedUsingPATCH.');
        }
        if (memoryGameRequest === null || memoryGameRequest === undefined) {
            throw new Error('Required parameter memoryGameRequest was null or undefined when calling updateMemoryGamedUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<MemoryGameResponse>(`${this.configuration.basePath}/tasks/memoryGame/${encodeURIComponent(String(taskId))}`,
            memoryGameRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Pairing task by taskId.
     *
     * @param taskId taskId
     * @param pairingRequest pairingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePairingByIdUsingPATCH(taskId: number, pairingRequest: PairingRequest, observe?: 'body', reportProgress?: boolean): Observable<PairingResponse>;
    public updatePairingByIdUsingPATCH(taskId: number, pairingRequest: PairingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PairingResponse>>;
    public updatePairingByIdUsingPATCH(taskId: number, pairingRequest: PairingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PairingResponse>>;
    public updatePairingByIdUsingPATCH(taskId: number, pairingRequest: PairingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updatePairingByIdUsingPATCH.');
        }
        if (pairingRequest === null || pairingRequest === undefined) {
            throw new Error('Required parameter pairingRequest was null or undefined when calling updatePairingByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<PairingResponse>(`${this.configuration.basePath}/tasks/pairing/${encodeURIComponent(String(taskId))}`,
            pairingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Sentence completion task by taskId.
     *
     * @param taskId taskId
     * @param sentenceCompletionRequest sentenceCompletionRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSentenceCompletionByIdUsingPATCH(taskId: number, sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'body', reportProgress?: boolean): Observable<SentenceCompletionResponse>;
    public updateSentenceCompletionByIdUsingPATCH(taskId: number, sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SentenceCompletionResponse>>;
    public updateSentenceCompletionByIdUsingPATCH(taskId: number, sentenceCompletionRequest: SentenceCompletionRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SentenceCompletionResponse>>;
    public updateSentenceCompletionByIdUsingPATCH(taskId: number, sentenceCompletionRequest: SentenceCompletionRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateSentenceCompletionByIdUsingPATCH.');
        }
        if (sentenceCompletionRequest === null || sentenceCompletionRequest === undefined) {
            throw new Error('Required parameter sentenceCompletionRequest was null or undefined when calling updateSentenceCompletionByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<SentenceCompletionResponse>(`${this.configuration.basePath}/tasks/sentence_completion/${encodeURIComponent(String(taskId))}`,
            sentenceCompletionRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Sentence creation task by taskId.
     *
     * @param taskId taskId
     * @param sentenceCreationRequest sentenceCreationRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSentenceCreationByIdUsingPATCH(taskId: number, sentenceCreationRequest: SentenceCreationRequest, observe?: 'body', reportProgress?: boolean): Observable<SentenceCreationResponse>;
    public updateSentenceCreationByIdUsingPATCH(taskId: number, sentenceCreationRequest: SentenceCreationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SentenceCreationResponse>>;
    public updateSentenceCreationByIdUsingPATCH(taskId: number, sentenceCreationRequest: SentenceCreationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SentenceCreationResponse>>;
    public updateSentenceCreationByIdUsingPATCH(taskId: number, sentenceCreationRequest: SentenceCreationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateSentenceCreationByIdUsingPATCH.');
        }
        if (sentenceCreationRequest === null || sentenceCreationRequest === undefined) {
            throw new Error('Required parameter sentenceCreationRequest was null or undefined when calling updateSentenceCreationByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<SentenceCreationResponse>(`${this.configuration.basePath}/tasks/sentence_creation/${encodeURIComponent(String(taskId))}`,
            sentenceCreationRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing Sorting task by taskId.
     *
     * @param taskId taskId
     * @param sortingRequest sortingRequest
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSortingByIdUsingPATCH(taskId: number, sortingRequest: SortingRequest, observe?: 'body', reportProgress?: boolean): Observable<SortingResponse>;
    public updateSortingByIdUsingPATCH(taskId: number, sortingRequest: SortingRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SortingResponse>>;
    public updateSortingByIdUsingPATCH(taskId: number, sortingRequest: SortingRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SortingResponse>>;
    public updateSortingByIdUsingPATCH(taskId: number, sortingRequest: SortingRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateSortingByIdUsingPATCH.');
        }
        if (sortingRequest === null || sortingRequest === undefined) {
            throw new Error('Required parameter sortingRequest was null or undefined when calling updateSortingByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<SortingResponse>(`${this.configuration.basePath}/tasks/sorting/${encodeURIComponent(String(taskId))}`,
            sortingRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates existing TrueFalse task by taskId.
     *
     * @param taskId taskId
     * @param trueFalseRequest request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTrueFalseByIdUsingPATCH(taskId: number, trueFalseRequest: TrueFalseRequest, observe?: 'body', reportProgress?: boolean): Observable<TrueFalseResponse>;
    public updateTrueFalseByIdUsingPATCH(taskId: number, trueFalseRequest: TrueFalseRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrueFalseResponse>>;
    public updateTrueFalseByIdUsingPATCH(taskId: number, trueFalseRequest: TrueFalseRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrueFalseResponse>>;
    public updateTrueFalseByIdUsingPATCH(taskId: number, trueFalseRequest: TrueFalseRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (taskId === null || taskId === undefined) {
            throw new Error('Required parameter taskId was null or undefined when calling updateTrueFalseByIdUsingPATCH.');
        }
        if (trueFalseRequest === null || trueFalseRequest === undefined) {
            throw new Error('Required parameter trueFalseRequest was null or undefined when calling updateTrueFalseByIdUsingPATCH.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKey) required
        if (this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            '*/*'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.patch<TrueFalseResponse>(`${this.configuration.basePath}/tasks/trueFalse/${encodeURIComponent(String(taskId))}`,
            trueFalseRequest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
